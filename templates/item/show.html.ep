% layout 'default';
% my $item = stash('item');
% title $item->{name};

<div class="item-page">
    <a href="/" class="btn btn-secondary">&larr; Back to Dashboard</a>

    <div class="item-header card">
        <div class="item-info">
            <div class="item-identity">
                <img src="/images/items/<%= $item->{id} %>.png"
                     alt="<%= $item->{name} %>" class="item-icon-large"
                     onerror="this.style.display='none'">
                <div class="item-name"><%= $item->{name} %></div>
            </div>
            <div class="item-meta">
                % if ($item->{ge_limit}) {
                    <span class="meta-item">Limit: <strong><%= $item->{ge_limit} %></strong></span>
                % }
                % my $daily_vol = ($item->{vol_24h_high} // 0) + ($item->{vol_24h_low} // 0);
                % if ($daily_vol) {
                    <span class="meta-item">Daily volume: <strong><%= format_vol($daily_vol) %></strong></span>
                % }
                <span class="meta-item meta-links">
                    <a href="https://oldschool.runescape.wiki/w/Special:Lookup?type=item&id=<%= $item->{id} %>" target="_blank">Wiki</a>
                    &middot;
                    <a href="https://prices.runescape.wiki/osrs/item/<%= $item->{id} %>" target="_blank">Prices</a>
                    &middot;
                    <a href="https://www.ge-tracker.com/item/<%= $item->{id} %>" target="_blank">GE Tracker</a>
                </span>
            </div>
        </div>
        <div class="hero-prices">
            <div class="hero-price hero-buy">
                <div class="hero-main">
                    <span class="hero-arrow">&#9650;</span>
                    <span class="hero-value"><%= format_gp($item->{high_price}) %></span>
                </div>
                % if ($item->{high_time}) {
                    <div class="hero-time"><%= time_ago($item->{high_time}) %></div>
                % }
            </div>
            <div class="hero-price hero-sell">
                <div class="hero-main">
                    <span class="hero-arrow">&#9660;</span>
                    <span class="hero-value"><%= format_gp($item->{low_price}) %></span>
                </div>
                % if ($item->{low_time}) {
                    <div class="hero-time"><%= time_ago($item->{low_time}) %></div>
                % }
            </div>
            <div class="hero-price hero-margin">
                % my $margin = ($item->{high_price} // 0) - ($item->{low_price} // 0);
                <div class="hero-value <%= $margin > 0 ? 'positive' : 'negative' %>"><%= format_gp($margin) %></div>
                <div class="hero-time">Margin</div>
            </div>
        </div>
        <div class="chart-controls" style="text-align:right;margin-top:1rem">
            <select id="timestep-select" style="width:auto">
                <option value="5m" selected>5 Minutes</option>
                <option value="1h">1 Hour</option>
                <option value="6h">6 Hours</option>
                <option value="24h">24 Hours</option>
            </select>
        </div>
        <div class="chart-container">
            <canvas id="price-chart"></canvas>
        </div>
        <div id="chart-loading" class="chart-loading">Loading price history...</div>
        <div id="chart-error" class="chart-error" style="display:none">Failed to load price history</div>
    </div>
</div>

% content_for 'scripts' => begin
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script>
const itemId = <%= $item->{id} %>;
let chart = null;
let chartData = { high: [], low: [] };
let crosshairX = null;
let highlightedPoints = { high: null, low: null };
let isDragging = false;
let dragStart = null;
let dragEnd = null;
let selectedRange = null; // { startX, endX } in pixel coords when selection is locked
let justFinishedDrag = false;

// Create tooltip once
const tooltip = document.createElement('div');
tooltip.id = 'chart-tooltip';
tooltip.style.cssText = 'position:fixed;background:rgba(255,255,255,0.95);color:#374151;padding:8px 12px;border-radius:4px;font-size:12px;pointer-events:none;z-index:1000;display:none;box-shadow:0 2px 8px rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.1);';
document.body.appendChild(tooltip);

// Create selection stats panel
const selectionStats = document.createElement('div');
selectionStats.id = 'selection-stats';
selectionStats.style.cssText = 'position:absolute;top:8px;right:8px;background:rgba(255,255,255,0.95);color:#374151;padding:8px 12px;border-radius:4px;font-size:12px;z-index:100;display:none;box-shadow:0 2px 8px rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.1);';
document.querySelector('.chart-container').appendChild(selectionStats);

async function loadPriceHistory(timestep) {
    const loading = document.getElementById('chart-loading');
    const error = document.getElementById('chart-error');
    loading.style.display = 'block';
    error.style.display = 'none';

    try {
        const response = await fetch(`/api/items/${itemId}/history?timestep=${timestep}`);
        if (!response.ok) throw new Error('Failed to fetch');

        const result = await response.json();
        const data = result.data || [];

        if (data.length === 0) {
            throw new Error('No data');
        }

        renderChart(data, timestep);
        loading.style.display = 'none';
    } catch (err) {
        console.error('Failed to load price history:', err);
        loading.style.display = 'none';
        error.style.display = 'block';
    }
}

// Find nearest point in dataset to given x value
function findNearestPoint(data, xValue) {
    if (!data || data.length === 0) return null;

    let nearestIdx = 0;
    let minDist = Math.abs(data[0].x - xValue);

    for (let i = 1; i < data.length; i++) {
        const dist = Math.abs(data[i].x - xValue);
        if (dist < minDist) {
            minDist = dist;
            nearestIdx = i;
        }
    }
    return nearestIdx;
}

// Find all points in dataset within x range
function findPointsInRange(data, minX, maxX) {
    if (!data || data.length === 0) return [];
    const indices = [];
    for (let i = 0; i < data.length; i++) {
        if (data[i].x >= minX && data[i].x <= maxX) {
            indices.push(i);
        }
    }
    return indices;
}

// Plugin to draw crosshair, selection area, and highlighted points
const crosshairPlugin = {
    id: 'crosshair',
    afterDatasetsDraw: (chart) => {
        const ctx = chart.ctx;
        const xAxis = chart.scales.x;
        const yAxis = chart.scales.y;
        const datasets = chart.data.datasets;
        const colors = ['#f87171', '#3b82f6'];

        // Draw selection rectangle if dragging or have selection
        const startX = selectedRange ? selectedRange.startX : (isDragging ? dragStart : null);
        const endX = selectedRange ? selectedRange.endX : (isDragging ? dragEnd : null);

        // Draw selection rectangle if exists
        if (startX !== null && endX !== null) {
            const left = Math.min(startX, endX);
            const width = Math.abs(endX - startX);

            ctx.save();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fillRect(left, yAxis.top, width, yAxis.bottom - yAxis.top);
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(left, yAxis.top, width, yAxis.bottom - yAxis.top);
            ctx.restore();

            // Draw all points in range
            const minXVal = xAxis.getValueForPixel(left);
            const maxXVal = xAxis.getValueForPixel(left + width);
            const rangeMinX = Math.min(minXVal, maxXVal);
            const rangeMaxX = Math.max(minXVal, maxXVal);

            [chartData.high, chartData.low].forEach((data, dsIdx) => {
                const indices = findPointsInRange(data, rangeMinX, rangeMaxX);
                indices.forEach(idx => {
                    const point = data[idx];
                    const x = xAxis.getPixelForValue(point.x);
                    const y = yAxis.getPixelForValue(point.y);

                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = colors[dsIdx];
                    ctx.fill();
                    ctx.restore();
                });
            });
        }

        // Draw crosshair and hover points (even if selection exists, but not while dragging)
        if (crosshairX !== null && !isDragging) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(crosshairX, yAxis.top);
            ctx.lineTo(crosshairX, yAxis.bottom);
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.setLineDash([4, 4]);
            ctx.stroke();
            ctx.restore();

            const indices = [highlightedPoints.high, highlightedPoints.low];
            indices.forEach((idx, dsIdx) => {
                if (idx === null) return;
                const point = datasets[dsIdx].data[idx];
                if (!point) return;

                const x = xAxis.getPixelForValue(point.x);
                const y = yAxis.getPixelForValue(point.y);

                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fillStyle = colors[dsIdx];
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            });
        }
    }
};

function renderChart(data, timestep) {
    const ctx = document.getElementById('price-chart').getContext('2d');

    // Prepare data points
    chartData.high = [];
    chartData.low = [];

    data.forEach(point => {
        const timestamp = point.timestamp * 1000;
        if (point.avgHighPrice) {
            chartData.high.push({ x: timestamp, y: point.avgHighPrice, vol: point.highPriceVolume || 0 });
        }
        if (point.avgLowPrice) {
            chartData.low.push({ x: timestamp, y: point.avgLowPrice, vol: point.lowPriceVolume || 0 });
        }
    });

    // Destroy existing chart
    if (chart) {
        chart.destroy();
    }

    // Reset state
    crosshairX = null;
    highlightedPoints = { high: null, low: null };
    selectedRange = null;
    isDragging = false;
    justFinishedDrag = false;
    selectionStats.style.display = 'none';

    // Calculate y-axis precision based on data range
    const allPrices = [...chartData.high.map(p => p.y), ...chartData.low.map(p => p.y)];
    const maxPrice = Math.max(...allPrices);
    const priceRange = maxPrice - Math.min(...allPrices);

    let yPrecision = 1;
    if (maxPrice >= 1000000 && priceRange / 1000000 < 0.5) yPrecision = 2;

    chart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: 'Instant Buy (Ask)',
                    data: chartData.high,
                    borderColor: '#f87171',
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    borderWidth: 2,
                },
                {
                    label: 'Instant Sell (Bid)',
                    data: chartData.low,
                    borderColor: '#3b82f6',
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    borderWidth: 2,
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: { enabled: false }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: { '5m': 'hour', '1h': 'day', '6h': 'week', '24h': 'month' }[timestep] },
                    ticks: { color: '#6b7280', maxRotation: 0 },
                    grid: { color: 'rgba(0, 0, 0, 0.1)' }
                },
                y: {
                    ticks: {
                        color: '#6b7280',
                        callback: value => formatGpCompact(value, yPrecision)
                    },
                    grid: { color: 'rgba(0, 0, 0, 0.1)' }
                }
            }
        },
        plugins: [crosshairPlugin]
    });
}

function formatGp(num) {
    if (num === null || num === undefined) return 'N/A';
    return num.toLocaleString() + ' gp';
}

function formatGpCompact(num, precision) {
    const p = precision || 1;
    if (num >= 1000000000) return (num / 1000000000).toFixed(p) + 'B';
    if (num >= 1000000) return (num / 1000000).toFixed(p) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(p) + 'K';
    return num.toString();
}

// Shared interaction functions
const canvas = document.getElementById('price-chart');
let pointerStartX = null;
let pointerMoved = false;

function getChartX(clientX) {
    const rect = canvas.getBoundingClientRect();
    return clientX - rect.left;
}

function isInChartArea(x) {
    if (!chart) return false;
    const chartArea = chart.chartArea;
    return x >= chartArea.left && x <= chartArea.right;
}

function clampToChartArea(x) {
    const chartArea = chart.chartArea;
    return Math.max(chartArea.left, Math.min(chartArea.right, x));
}

function buildTooltipHtml() {
    let html = '';
    const fmt = { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' };
    if (highlightedPoints.high !== null) {
        const p = chartData.high[highlightedPoints.high];
        const time = new Date(p.x).toLocaleString('en-US', fmt);
        html += `<div style="color:#dc2626;font-weight:600">▲ ${formatGp(p.y)}</div>`;
        html += `<div style="color:#6b7280;font-size:10px">${time} · <strong>${p.vol.toLocaleString()}</strong> vol</div>`;
    }
    if (highlightedPoints.low !== null) {
        const p = chartData.low[highlightedPoints.low];
        const time = new Date(p.x).toLocaleString('en-US', fmt);
        html += `<div style="color:#2563eb;font-weight:600;${highlightedPoints.high !== null ? 'margin-top:6px' : ''}">▼ ${formatGp(p.y)}</div>`;
        html += `<div style="color:#6b7280;font-size:10px">${time} · <strong>${p.vol.toLocaleString()}</strong> vol</div>`;
    }
    return html;
}

function startDrag(x) {
    pointerStartX = x;
    pointerMoved = false;
    isDragging = true;
    dragStart = x;
    dragEnd = x;
    selectedRange = null;
    selectionStats.style.display = 'none';
    crosshairX = null;
    tooltip.style.display = 'none';
    chart.draw();
}

function updateDrag(x) {
    if (Math.abs(x - pointerStartX) > 10) {
        pointerMoved = true;
        crosshairX = null;
        tooltip.style.display = 'none';
    }
    dragEnd = clampToChartArea(x);
    chart.draw();
}

function showTooltipAt(x, screenX, screenY) {
    crosshairX = x;
    const xValue = chart.scales.x.getValueForPixel(x);
    highlightedPoints.high = findNearestPoint(chartData.high, xValue);
    highlightedPoints.low = findNearestPoint(chartData.low, xValue);

    tooltip.innerHTML = buildTooltipHtml();
    tooltip.style.display = 'block';
    if (screenX !== null && screenY !== null) {
        tooltip.style.left = (screenX + 15) + 'px';
        tooltip.style.top = (screenY - 10) + 'px';
    } else {
        // Fixed position for touch
        const rect = canvas.getBoundingClientRect();
        tooltip.style.left = (rect.right - 150) + 'px';
        tooltip.style.top = (rect.top + 10) + 'px';
    }
    chart.draw();
}

function hideTooltip() {
    crosshairX = null;
    highlightedPoints = { high: null, low: null };
    tooltip.style.display = 'none';
    chart.draw();
}

function finishDrag() {
    if (!chart || !isDragging) return;

    if (Math.abs(dragEnd - dragStart) > 5) {
        selectedRange = { startX: dragStart, endX: dragEnd };
        justFinishedDrag = true;

        const left = Math.min(dragStart, dragEnd);
        const width = Math.abs(dragEnd - dragStart);
        const minXVal = chart.scales.x.getValueForPixel(left);
        const maxXVal = chart.scales.x.getValueForPixel(left + width);
        const rangeMinX = Math.min(minXVal, maxXVal);
        const rangeMaxX = Math.max(minXVal, maxXVal);

        const highIndices = findPointsInRange(chartData.high, rangeMinX, rangeMaxX);
        const lowIndices = findPointsInRange(chartData.low, rangeMinX, rangeMaxX);

        const allTimes = [
            ...highIndices.map(i => chartData.high[i].x),
            ...lowIndices.map(i => chartData.low[i].x)
        ];
        const minTime = new Date(Math.min(...allTimes));
        const maxTime = new Date(Math.max(...allTimes));
        const fmt = { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' };
        const rangeLabel = `${minTime.toLocaleString('en-US', fmt)} – ${maxTime.toLocaleString('en-US', fmt)}`;

        let html = `<div style="font-weight:600;margin-bottom:4px">${rangeLabel}</div>`;

        if (highIndices.length > 0) {
            const points = highIndices.map(i => chartData.high[i]);
            const prices = points.map(p => p.y);
            const totalVol = points.reduce((sum, p) => sum + p.vol, 0);
            const avg = prices.reduce((a, b) => a + b, 0) / prices.length;
            html += `<div style="color:#dc2626;font-weight:600">▲ Avg: ${formatGp(Math.round(avg))}</div>`;
            html += `<div style="color:#6b7280;font-size:10px">${formatGp(Math.min(...prices))} – ${formatGp(Math.max(...prices))}</div>`;
            html += `<div style="color:#374151;font-weight:600;margin-bottom:6px">${totalVol.toLocaleString()} vol</div>`;
        }

        if (lowIndices.length > 0) {
            const points = lowIndices.map(i => chartData.low[i]);
            const prices = points.map(p => p.y);
            const totalVol = points.reduce((sum, p) => sum + p.vol, 0);
            const avg = prices.reduce((a, b) => a + b, 0) / prices.length;
            html += `<div style="color:#2563eb;font-weight:600">▼ Avg: ${formatGp(Math.round(avg))}</div>`;
            html += `<div style="color:#6b7280;font-size:10px">${formatGp(Math.min(...prices))} – ${formatGp(Math.max(...prices))}</div>`;
            html += `<div style="color:#374151;font-weight:600">${totalVol.toLocaleString()} vol</div>`;
        }

        selectionStats.innerHTML = html;
        selectionStats.style.display = 'block';
    }

    isDragging = false;
    dragStart = null;
    dragEnd = null;
    chart.draw();
}

function endInteraction(isTap) {
    if (isTap && pointerStartX !== null) {
        isDragging = false;
        dragStart = null;
        dragEnd = null;
        showTooltipAt(pointerStartX, null, null);
    } else {
        finishDrag();
    }
    pointerStartX = null;
    pointerMoved = false;
}

// Mouse events
canvas.addEventListener('mousedown', (e) => {
    if (!chart) return;
    const x = getChartX(e.clientX);
    if (isInChartArea(x)) startDrag(x);
});

canvas.addEventListener('mousemove', (e) => {
    if (!chart) return;
    const x = getChartX(e.clientX);

    if (isDragging) {
        updateDrag(x);
        return;
    }

    if (!isInChartArea(x)) {
        hideTooltip();
        return;
    }

    showTooltipAt(x, e.clientX, e.clientY);
});

canvas.addEventListener('mouseup', finishDrag);
document.addEventListener('mouseup', finishDrag);

canvas.addEventListener('mouseleave', () => {
    if (!chart) return;
    if (!selectedRange && !isDragging) hideTooltip();
});

// Touch events
canvas.addEventListener('touchstart', (e) => {
    if (!chart) return;
    const x = getChartX(e.touches[0].clientX);
    if (isInChartArea(x)) {
        e.preventDefault();
        startDrag(x);
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    if (!chart || !isDragging) return;
    e.preventDefault();
    updateDrag(getChartX(e.touches[0].clientX));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    if (!chart || !isDragging) return;
    e.preventDefault();
    endInteraction(!pointerMoved);
});

// Touch outside chart clears tooltip and selection
document.addEventListener('touchstart', (e) => {
    if (!chart || e.target === canvas) return;
    hideTooltip();
    if (selectedRange) {
        selectedRange = null;
        selectionStats.style.display = 'none';
        chart.draw();
    }
});

// Click to clear selection
canvas.addEventListener('click', (e) => {
    if (!chart) return;
    if (justFinishedDrag) {
        justFinishedDrag = false;
        return;
    }

    if (selectedRange) {
        selectedRange = null;
        selectionStats.style.display = 'none';
        chart.draw();
    }
});

// Initialize
document.getElementById('timestep-select').addEventListener('change', function() {
    loadPriceHistory(this.value);
});

loadPriceHistory(document.getElementById('timestep-select').value);
</script>
% end
